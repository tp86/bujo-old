lazy val fileToMonitor =
  settingKey[File]("File monitored for changes to trigger resource generation.")
lazy val filesToGenerate =
  settingKey[Map[File, String]]("Files to generate with their contents.")
lazy val generateResources =
  taskKey[Seq[File]]("Generate resources dynamically.")
lazy val generateResourcesImpl: Def.Initialize[Task[Seq[File]]] = Def.task {
  import sbt.util.CacheImplicits.{seqFormat => _, _}
  val previousValue = generateResources.previous
  val s = streams.value
  def write(
      file: File,
      contents: String,
    ): File = {
    s.log.info(s"Generating ${file.name}")
    val generateContents =
      "# This file is autogenerated. DO NOT EDIT manually.\n" + contents
    IO.write(file, generateContents)
    file
  }
  def writeAll(files: Map[File, String]): Seq[File] = {
    (files map { case (file, contents) => write(file, contents) }).toSeq
  }
  val cachedGenerator = Tracked.inputChanged[HashFileInfo, Seq[File]](
    s.cacheStoreFactory.make("res_gen"),
  ) { (changed: Boolean, _: HashFileInfo) =>
    previousValue match {
      case None => writeAll(filesToGenerate.value)
      case Some(generated) =>
        if (
          changed || filesToGenerate.value.exists { case (file, _) =>
            !file.exists
          }
        ) writeAll(filesToGenerate.value)
        else generated
    }
  }
  cachedGenerator(FileInfo.hash(fileToMonitor.value))
}

lazy val init = taskKey[Unit]("")
lazy val repo = project
  .in(file("."))
  .aggregate(migrations, generatedCode)
  .settings(
    scalaVersion := "2.13.5",
    fileToMonitor := baseDirectory.value / "build.sbt",
    filesToGenerate := Map(
      baseDirectory.value / "src/main/generated-resources" / "db.conf" ->
        s"""slick.db.url = "jdbc:sqlite:${(baseDirectory.value / "db/test.db").getCanonicalPath}"""",
    ),
    Compile / unmanagedResourceDirectories += baseDirectory.value / "src/main/generated-resources",
    generateResources := generateResourcesImpl.value,
    Compile / resourceGenerators += generateResources.taskValue,
    init := {
      (Compile / generateResources).value
      (migrations / Compile / run).toTask(" init").value
    },
  )

lazy val migrationsDeps = Seq(
  "com.typesafe.slick" %% "slick" % "3.3.3",
  "com.liyaos" %% "scala-forklift-slick" % "0.3.2",
  "com.typesafe.slick" %% "slick-hikaricp" % "3.3.3",
  "org.slf4j" % "slf4j-nop" % "2.0.0-alpha1",
  "org.xerial" % "sqlite-jdbc" % "3.34.0",
)
lazy val migrations = project
  .in(file("migrations"))
  .dependsOn(generatedCode)
  .settings(
    scalaVersion := "2.13.5",
    resolvers += Resolver.jcenterRepo,
    libraryDependencies ++= migrationsDeps,
    addCommandAlias("migrate", "migrations/run"),
    fileToMonitor := baseDirectory.value / ".." / "build.sbt",
    filesToGenerate := Map(
      baseDirectory.value / "src/main/generated-resources" / "migrations.conf" ->
        s"""|migrations {
            |    handled_location=${(baseDirectory.value / "src/main/scala").getCanonicalPath}
            |}""".stripMargin,
    ),
    Compile / unmanagedResourceDirectories += baseDirectory.value / ".." / "src/main/resources",
    Compile / unmanagedResourceDirectories += baseDirectory.value / ".." / "src/main/generated-resources",
    Compile / unmanagedResourceDirectories += baseDirectory.value / "src/main/generated-resources",
    generateResources := generateResourcesImpl.value,
    Compile / resourceGenerators += generateResources.taskValue,
  )

lazy val generatedCode = project
  .in(file("generated_code"))
  .settings(
    scalaVersion := "2.13.5",
  )
